# 대용량 트래픽 환경을 고려한 백엔드 시스템 설계 및 성능 검증

> **메타데이터 중심 설계 + Redis 캐시 + 비동기 처리 + Object Storage 분리**를 통해  
> 대용량 트래픽 및 동시성 환경에서의 병목을 정의하고,  
> **설계 변경이 실제 성능과 안정성에 어떤 영향을 미치는지 정량적으로 검증한 프로젝트**입니다.

---
## 📄 프로젝트 문서

- **API 명세서 (Notion)**  
  👉 https://deluxe-peripheral-82c.notion.site/API-Document-2e5ae307a79080dcb3ecfb0566e2fa01?source=copy_link

- **설계 및 성능 검증 보고서 (PDF)**  
  👉 [`docs/대용량_트래픽_환경을_고려한_백엔드_시스템_설계_및_성능_검증_보고서.pdf`](./docs/대용량%20트래픽%20환경을%20고려한%20백엔드%20시스템%20설계%20및%20성능%20검증%20보고서.pdf)
---
## 1. 프로젝트 배경

대규모 서비스 환경에서는 단순한 CRUD 구현만으로는 다음과 같은 문제가 발생합니다.

- 특정 게시물에 조회 트래픽이 집중될 경우 **DB 병목**
- 좋아요와 같은 카운터성 데이터에서 **동시성 충돌 및 정합성 문제**
- 이미지·PDF 등 대용량 파일 업로드 시 **서버 자원 고갈**
- 트래픽 증가 시 **불필요한 DB 직접 접근으로 인한 확장성 저하**

본 프로젝트는 이러한 문제를 **기능 구현 이후가 아닌 설계 단계에서 정의하고 검증**하는 것을 목표로 진행되었습니다.

---

## 2. 프로젝트 목표

- 대용량 트래픽 환경에서 발생 가능한 **병목 지점 명확화**
- Redis, 비동기 처리, Object Storage 분리 설계의 **실제 효과 검증**
- 평균 응답 시간뿐 아니라 **Tail Latency(p95)** 관점에서의 성능 개선 여부 확인
- 동시성 환경에서도 **데이터 정합성과 시스템 안정성 유지 여부 검증**

---

## 3. 시스템 아키텍처 개요

### 설계 핵심 원칙

- **메타데이터 중심 설계**  
  → 파일 데이터는 DB에 저장하지 않고 Object Storage로 분리
- **DB 보호 우선**  
  → 캐시는 보조 수단, 데이터 정합성의 기준은 DB
- **동시성 다계층 방어**  
  → 애플리케이션 로직 + DB 제약 조건 병행
- **수치 기반 검증**  
  → 추측이 아닌 부하 테스트 결과로 설계 판단 검증

### 구성 요소

- Spring Boot (API 서버)
- MySQL (메타데이터 저장소)
- Redis (조회 캐시, 카운터성 데이터 처리)
- MinIO (Object Storage)
- Docker Compose (실행 및 테스트 환경 구성)

---

## 4. 도메인 설계

| 도메인 | 설계 의도 |
|------|---------|
| Post | 조회 트래픽 집중 대상 → 캐시 적용 기준 |
| Like | 동시성 및 정합성 검증 핵심 도메인 |
| User | 인증 및 행위 주체 |
| Content | 파일은 Object Storage, DB에는 메타데이터만 저장 |

---

## 5. 테스트 전략

기능 검증을 넘어 **운영 환경에서 의미 있는 질문에 답하는 테스트**를 설계했습니다.

### 테스트 유형

- 단위 테스트 / 통합 테스트 (JUnit)
- 동시성 테스트 (좋아요 중복 생성 여부)
- 부하 테스트 (k6)

### 검증 시나리오

- Redis 캐시 적용 전/후 게시물 조회 성능 비교
- 동시 좋아요 요청에서 데이터 정합성 유지 여부
- 비동기 이벤트 처리 적용 시 DB 보호 효과
- 대용량 파일 업로드 환경에서의 시스템 안정성

---

## 6. 주요 테스트 결과

### 1️⃣ 게시물 조회 성능 (Redis 적용 전/후)

| 지표 | Redis 적용 전 | Redis 적용 후 |
|----|-------------|-------------|
| 평균 응답 시간 | 629ms | **491ms (-22%)** |
| p95 Latency | 1,690ms | **1,060ms (-37%)** |

- 동일 조건에서 **처리 가능한 동시 사용자 수 약 2.7배 증가**
- 평균 응답뿐 아니라 **Tail Latency 구간이 크게 개선**
- DB 병목 완화 효과를 수치로 검증

---

### 2️⃣ 좋아요 동시성 및 정합성 검증

- 동일 사용자–게시물 조합에 대해 **중복 좋아요 미발생**
- 동시 요청 환경에서도 Like row는 항상 **1건만 유지**
- 애플리케이션 보호 로직 + DB Unique Constraint 병행 설계의 효과 확인

---

### 3️⃣ 비동기 처리 기반 DB 보호

- 동시 좋아요 요청 집중 상황에서도
    - Deadlock 없음
    - 시스템 중단 없음
- DB 충돌이 서비스 장애로 전파되지 않도록 설계됨을 검증

---

### 4️⃣ 대용량 파일 업로드 안정성

- 파일 크기: 약 2.4MB
- 동시 업로드 환경에서도 **실패율 0%, 서버 다운 없음**
- 업로드 도메인에서는 응답 속도보다  
  **시스템 안정성과 실패율 관리가 더 중요한 지표임을 확인**

---

## 7. 프로젝트에서 강조하고 싶은 점

- Redis 도입 자체가 아니라 **왜 필요한지, 어떤 문제를 해결하는지**를 중심으로 설계
- 평균 응답 시간이 아닌 **Tail Latency(p95) 중심 성능 해석**
- 동시성 문제를 단일 계층이 아닌 **다계층 방어 구조로 해결**
- 모든 설계 판단을 **정량적인 테스트 결과로 검증**

---

## 8. 기술 스택

- Java 17
- Spring Boot
- JPA (Hibernate)
- MySQL
- Redis
- MinIO
- Docker / Docker Compose
- k6
- JUnit 5

---

## 9. 정리

본 프로젝트는  
**대용량 트래픽 및 동시성 환경에서 어떤 설계가 왜 필요한지,  
그리고 그 설계가 실제로 효과가 있는지를 증명하는 데 초점**을 둔 프로젝트입니다.

문제 정의 → 설계 변경 → 검증 → 해석의 과정을 반복하며  
실무 환경에서의 시스템 설계 판단에 활용 가능한 경험을 축적하는 것을 목표로 했습니다.
